#!/bin/sh /etc/rc.common

START=99
USE_PROCD=1

script=$(readlink "$initscript")
NAME="$(basename ${script:-$initscript})"
config_load "$NAME"

EXTRA_COMMANDS="list_update add_route_interface"
EXTRA_HELP="        list_update     Updating domain and subnet lists
        add_route_interface  Adding route for interface
        sing_box_config_vless For test vless string"

config_get update_interval "main" "update_interval" "0 4 * * *"
cron_job="${update_interval} /etc/init.d/podkop list_update"

start_service() {
    log "Start podkop"

    dnsmasqfull
    routing_table_create
    add_mark

    config_get mode "main" "mode"
    case "$mode" in
    "vpn")
        log "VPN mode"
        log "You are using VPN mode, make sure you have installed all the necessary packages, configured, created the zone and forwarding."
        config_get interface "main" "interface" "0"
        if [ -n "$interface" ]; then
            add_route_interface "$interface" "podkop"
        else
            log "Interface undefined"
        fi

        config_get_bool second_enable "second" "second_enable" "0"
        config_get second_mode "second" "second_mode" "0"
        if [ "$second_enable" -eq "1" ] && [ "$second_mode" = "proxy" ]; then
            config_get proxy_config_type "second" "second_proxy_config_type"
            
            if [ "$proxy_config_type" = "outbound" ]; then
                config_get outbound_json "second" "second_outbound_json"
                if [ -n "$outbound_json" ]; then
                    log "Using JSON outbound configuration for second proxy"
                    sing_box_config_outbound_json "$outbound_json" "1603"
                else
                    log "Missing outbound JSON configuration"
                    return
                fi
            else
                config_get proxy_string "second" "second_proxy_string"
                if [[ "$proxy_string" =~ ^ss:// ]]; then
                    sing_box_config_shadowsocks "$proxy_string" "1603"
                elif [[ "$proxy_string" =~ ^vless:// ]]; then
                    sing_box_config_vless "$proxy_string" "1603"
                else
                    log "Unsupported proxy type or missing configuration"
                    return
                fi
            fi
            add_route_tproxy podkop2
            sing_box_config_check
            sing_box_uci
            /etc/init.d/sing-box restart
            /etc/init.d/sing-box enable
        fi

        if [ "$second_enable" -eq "1" ] && [ "$second_mode" = "vpn" ]; then
            log "VPN mode for second"
            config_get interface "second" "second_interface" "0"
            if [ -n "$interface" ]; then
                add_route_interface "$interface" "podkop2"
            else
                log "Interface undefined"
            fi
        fi
        ;;
    "proxy")
        log "Proxy mode"
        if ! command -v sing-box >/dev/null 2>&1; then
            log "Sing-box isn't installed. Proxy mode works with sing-box"
            return
        fi

        # Main - proxy, Second - proxy
        config_get_bool second_enable "second" "second_enable" "0"
        config_get second_mode "second" "second_mode" "0"
        if [ "$second_enable" -eq "1" ] && [ "$second_mode" = "proxy" ]; then
            log "Two proxy enable"
            outbound_main=$(mktemp)
            outbound_second=$(mktemp)

            # Main proxy config
            config_get proxy_config_type main "proxy_config_type"
            if [ "$proxy_config_type" = "outbound" ]; then
                config_get outbound_json main "outbound_json"
                if [ -n "$outbound_json" ]; then
                    echo '{"outbounds":[' > "$outbound_main"
                    echo "$outbound_json" | jq '. + {tag: "main"}' >> "$outbound_main"
                    echo ']}' >> "$outbound_main"
                else
                    log "Missing main outbound JSON configuration"
                    rm -f "$outbound_main" "$outbound_second"
                    return
                fi
            else
                config_get proxy_string main "proxy_string"
                if [[ "$proxy_string" =~ ^ss:// ]]; then
                    sing_box_config_shadowsocks "$proxy_string" "1602"
                    jq '.outbounds[0] + {tag: "main"} | {outbounds: [.]}' /etc/sing-box/config.json > "$outbound_main"
                elif [[ "$proxy_string" =~ ^vless:// ]]; then
                    sing_box_config_vless "$proxy_string" "1602"
                    jq '.outbounds[0] + {tag: "main"} | {outbounds: [.]}' /etc/sing-box/config.json > "$outbound_main"
                else
                    log "Unsupported proxy type or missing configuration for main"
                    rm -f "$outbound_main" "$outbound_second"
                    return
                fi
            fi

            # Second proxy config
            config_get proxy_config_type second "second_proxy_config_type"
            if [ "$proxy_config_type" = "outbound" ]; then
                config_get outbound_json second "second_outbound_json"
                if [ -n "$outbound_json" ]; then
                    echo '{"outbounds":[' > "$outbound_second"
                    echo "$outbound_json" | jq '. + {tag: "second"}' >> "$outbound_second"
                    echo ']}' >> "$outbound_second"
                else
                    log "Missing second outbound JSON configuration"
                    rm -f "$outbound_main" "$outbound_second"
                    return
                fi
            else
                config_get proxy_string "second" "second_proxy_string"
                if [[ "$proxy_string" =~ ^ss:// ]]; then
                    sing_box_config_shadowsocks "$proxy_string" "1603"
                    jq '.outbounds[0] + {tag: "second"} | {outbounds: [.]}' /etc/sing-box/config.json > "$outbound_second"
                elif [[ "$proxy_string" =~ ^vless:// ]]; then
                    sing_box_config_vless "$proxy_string" "1603"
                    jq '.outbounds[0] + {tag: "second"} | {outbounds: [.]}' /etc/sing-box/config.json > "$outbound_second"
                else
                    log "Unsupported proxy type or missing configuration for second"
                    rm -f "$outbound_main" "$outbound_second"
                    return
                fi
            fi

            jq -s '{
                "log": {"level": "warn"},
                "inbounds": [
                    {
                        "type": "tproxy",
                        "listen": "::",
                        "listen_port": 1602,
                        "sniff": false,
                        "tag": "main"
                    },
                    {
                        "type": "tproxy",
                        "listen": "::",
                        "listen_port": 1603,
                        "sniff": false,
                        "tag": "second"
                    }
                ],
                "outbounds": (.[0].outbounds + .[1].outbounds),
                "route": {
                    "rules": [
                        {
                            "inbound": "main",
                            "outbound": "main"
                        },
                        {
                            "inbound": "second",
                            "outbound": "second"
                        }
                    ],
                    "auto_detect_interface": true
                }
            }' "$outbound_main" "$outbound_second" > /etc/sing-box/config.json

            rm -f "$outbound_main" "$outbound_second"

            add_route_tproxy podkop
            add_route_tproxy podkop2
        fi

        # Main proxy, second disable/vpn
        config_get_bool second_enable "second" "second_enable" "0"
        config_get second_mode "second" "second_mode" "0"
        if [ "$second_enable" -eq "0" ] || [ "$second_mode" = "vpn" ]; then
            config_get proxy_config_type main "proxy_config_type"
            
            if [ "$proxy_config_type" = "outbound" ]; then
                config_get outbound_json main "outbound_json"
                if [ -n "$outbound_json" ]; then
                    log "Using JSON outbound configuration"
                    sing_box_config_outbound_json "$outbound_json" "1602"
                else
                    log "Missing outbound JSON configuration"
                    return
                fi
            else
                config_get proxy_string main "proxy_string"
                if [[ "$proxy_string" =~ ^ss:// ]]; then
                    sing_box_config_shadowsocks "$proxy_string" "1602"
                elif [[ "$proxy_string" =~ ^vless:// ]]; then
                    sing_box_config_vless "$proxy_string" "1602"
                else
                    log "Unsupported proxy type or missing configuration"
                    return
                fi
            fi
            add_route_tproxy podkop
        fi

        sing_box_config_check
        sing_box_uci
        /etc/init.d/sing-box restart
        /etc/init.d/sing-box enable

        # Main proxy, Second VPN
        config_get_bool second_enable "second" "second_enable" "0"
        config_get second_mode "second" "second_mode" "0"
        if [ "$second_enable" -eq "1" ] && [ "$second_mode" = "vpn" ]; then
            log "VPN mode for seconds"
            log "You are using VPN mode, make sure you have installed all the necessary packages, configured, created the zone and forwarding."
            config_get interface "second" "second_interface" "0"
            if [ -n "$interface" ]; then
                add_route_interface "$interface" "podkop2"
            else
                log "Interface undefined"
            fi
        fi
        ;;
    *)
        log "Requires *vpn* or *proxy* value"
        return
        ;;
    esac

    list_update

    if [ "$domain_list_enabled" -eq 1 ] || [ "$subnets_list_enabled" -eq 1 ]; then
        add_cron_job
    fi

    config_get_bool all_traffic_from_ip_enabled "main" "all_traffic_from_ip_enabled" "0"
    if [ "$all_traffic_from_ip_enabled" -eq 1 ]; then
        log "Adding an IP to redirect all traffic"
        config_list_foreach main all_traffic_ip list_all_traffic_from_ip
    fi

    config_get_bool exclude_from_ip_enabled "main" "exclude_from_ip_enabled" "0"
    if [ "$exclude_from_ip_enabled" -eq 1 ]; then
        log "Adding an IP for exclusion"
        config_list_foreach main exclude_traffic_ip list_exclude_traffic_from_ip
    fi

    config_get_bool yacd "main" "yacd" "0"
    if [ "$yacd" -eq 1 ]; then
        log "Yacd enable"
        jq '.experimental.clash_api = {
            "external_ui": "ui",
            "external_controller": "0.0.0.0:9090"
        }' /etc/sing-box/config.json >/tmp/sing-box-config-tmp.json && mv /tmp/sing-box-config-tmp.json /etc/sing-box/config.json
        /etc/init.d/sing-box restart
    fi

    config_get_bool socks5 "main" "socks5" "0"
    if [ "$socks5" -eq 1 ]; then
        log "Socks5 local enable port 2080"
        jq '.inbounds += [{
            "type": "mixed",
            "listen": "0.0.0.0",
            "listen_port": 2080,
            "set_system_proxy": false
        }]' /etc/sing-box/config.json >/tmp/sing-box-config-tmp.json && mv /tmp/sing-box-config-tmp.json /etc/sing-box/config.json
        /etc/init.d/sing-box restart
    fi

    config_get_bool exclude_ntp "main" "exclude_ntp" "0"
    if [ "$exclude_ntp" -eq 1 ]; then
        log "NTP traffic exclude for proxy"
        nft insert rule inet PodkopTable mangle udp dport 123 return
    fi
}

stop_service() {
    log "Stopping the podkop"
    rm -f /tmp/dnsmasq.d/podkop*
    remove_cron_job

    log "Flush nft"
    if nft list table inet PodkopTable >/dev/null 2>&1; then
        nft delete table inet PodkopTable
    fi

    log "Flush ip rule"
    if ip rule list | grep -q "podkop"; then
        ip rule del fwmark 0x105 table podkop priority 105
    fi

    if ip rule list | grep -q "podkop2"; then
        ip rule del fwmark 0x106 table podkop2 priority 106
    fi

    log "Flush ip route"
    if ip route list table podkop; then
        ip route flush table podkop
    fi

    if ip route list table podkop2; then
        ip route flush table podkop2
    fi

    log "Stop sing-box"
    config_get mode_main "main" "mode" "0"
    config_get mode_second "second" "second_mode" "0"

    if [ "$mode_main" = "proxy" ] || [ "$mode_second" = "proxy" ]; then
        /etc/init.d/sing-box stop
        /etc/init.d/sing-box disable
    fi
}

restart_service() {
    stop
    start
}

reload_service() {
    stop
    start
}

service_triggers() {
    log "service_triggers start"
    procd_add_config_trigger "config.change" "$NAME" "$initscript" reload 'on_config_change'
}

log() {
    local message="$1"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local CYAN="\033[0;36m"
    local GREEN="\033[0;32m"
    local RESET="\033[0m"

    echo -e "${CYAN}[$timestamp]${RESET} ${GREEN}$message${RESET}"
    logger -t "podkop" "$timestamp $message"
}

add_cron_job() {
    remove_cron_job
    crontab -l | {
        cat
        echo "$cron_job"
    } | crontab -
    log "The cron job has been created: $cron_job"
}

remove_cron_job() {
    (crontab -l | grep -v "/etc/init.d/podkop list_update") | crontab -
    log "The cron job removed"
}

list_update() {
    # Main domains processing
    config_get_bool domain_list_enabled "main" "domain_list_enabled" "0"
    if [ "$domain_list_enabled" -eq 1 ]; then
        log "Adding a common domains list"
        add_set "podkop_domains" "main"
        config_get domain_list main "domain_list"
        lists_domains_download "$domain_list"
        dnsmasq_config_check podkop-domains.lst
    fi

    # Main custom domains processing
    config_get custom_domains_list_type "main" "custom_domains_list_enabled" "disabled"
    if [ "$custom_domains_list_type" != "disabled" ]; then
        log "Adding a custom domains list"
        add_set "podkop_domains" "main"
        rm -f /tmp/dnsmasq.d/podkop-custom-domains.lst
        
        if [ "$custom_domains_list_type" = "dynamic" ]; then
            config_list_foreach main custom_domains "list_custom_domains_create" "podkop"
        elif [ "$custom_domains_list_type" = "text" ]; then
            config_get custom_domains_text main "custom_domains_text"
            process_domains_text "$custom_domains_text" "podkop"
        fi
        
        dnsmasq_config_check podkop-custom-domains.lst
    fi

    # Main custom download domains
    config_get_bool custom_download_domains_list_enabled "main" "custom_download_domains_list_enabled" "0"
    if [ "$custom_download_domains_list_enabled" -eq 1 ]; then
        log "Adding a custom domains list from URL"
        add_set "podkop_domains" "main"
        config_list_foreach main custom_download_domains "list_custom_download_domains_create" "podkop"
    fi

    # Main domains delist
    config_get_bool delist_domains_enabled "main" "delist_domains_enabled" "0"
    if [ "$delist_domains_enabled" -eq 1 ] && [ "$domain_list_enabled" -eq 1 ]; then
        log "Exclude domains from the common list"
        config_list_foreach main delist_domains "list_delist_domains"
        dnsmasq_config_check podkop-domains.lst
    fi

    # Main subnets processing
    config_get_bool subnets_list_enabled "main" "subnets_list_enabled" "0"
    if [ "$subnets_list_enabled" -eq 1 ]; then
        log "Adding a subnets from list"
        mkdir -p /tmp/podkop
        add_set "podkop_subnets" "main"
        config_list_foreach main subnets "list_subnets_download"
    fi

    # Main custom subnets
    config_get custom_subnets_list_type "main" "custom_subnets_list_enabled" "disabled"
    if [ "$custom_subnets_list_type" != "disabled" ]; then
        log "Adding a custom subnets list"
        add_set "podkop_subnets" "main"
        
        if [ "$custom_subnets_list_type" = "dynamic" ]; then
            config_list_foreach main custom_subnets list_custom_subnets_preprocess "podkop"
        elif [ "$custom_subnets_list_type" = "text" ]; then
            config_get custom_subnets_text main "custom_subnets_text"
            process_subnets_text "$custom_subnets_text" "podkop"
        fi
    fi

    # Main custom download subnets
    config_get_bool custom_download_subnets_list_enabled "main" "custom_download_subnets_list_enabled" "0"
    if [ "$custom_download_subnets_list_enabled" -eq 1 ]; then
        log "Adding a subnets from URL"
        mkdir -p /tmp/podkop
        add_set "podkop_subnets" "main"
        config_list_foreach main custom_download_subnets "list_subnets_download"
    fi

    # Second custom domains processing
    config_get second_custom_domains_list_type "second" "second_custom_domains_list_enabled" "disabled"
    if [ "$second_custom_domains_list_type" != "disabled" ]; then
        log "Adding a custom domains list. Second podkop"
        add_set "podkop2_domains" "second"
        rm -f /tmp/dnsmasq.d/podkop2-custom-domains.lst
        
        if [ "$second_custom_domains_list_type" = "dynamic" ]; then
            config_list_foreach second second_custom_domains "list_custom_domains_create" "podkop2"
        elif [ "$second_custom_domains_list_type" = "text" ]; then
            config_get second_custom_domains_text second "second_custom_domains_text"
            process_domains_text "$second_custom_domains_text" "podkop2"
        fi
        
        dnsmasq_config_check podkop2-custom-domains.lst
    fi

    # Second service domains
    config_get_bool second_domain_service_enabled "second" "second_domain_service_enabled" "0"
    if [ "$second_domain_service_enabled" -eq 1 ]; then
        log "Adding a service for podkop2"
        add_set "podkop2_domains" "second"
        config_get second_service_list second "second_service_list"
        lists_services_download "$second_service_list"
        config_list_foreach second second_custom_domains "list_delist_domains"
        dnsmasq_config_check podkop2-domains.lst
    fi

    # Second custom subnets
    config_get second_custom_subnets_list_type "second" "second_custom_subnets_list_enabled" "disabled"
    if [ "$second_custom_subnets_list_type" != "disabled" ]; then
        log "Adding a custom subnets list. Second"
        add_set "podkop2_subnets" "second"
        
        if [ "$second_custom_subnets_list_type" = "dynamic" ]; then
            config_list_foreach second second_custom_subnets list_custom_subnets_preprocess "podkop2"
        elif [ "$second_custom_subnets_list_type" = "text" ]; then
            config_get second_custom_subnets_text second "second_custom_subnets_text"
            process_subnets_text "$second_custom_subnets_text" "podkop2"
        fi
    fi

    # Restart dnsmasq if needed
    if [ "$domain_list_enabled" -eq 1 ] || [ "$custom_domains_list_type" != "disabled" ] || \
       [ "$custom_download_domains_list_enabled" -eq 1 ] || \
       [ "$second_custom_domains_list_type" != "disabled" ] || \
       [ "$second_domain_service_enabled" -eq 1 ]; then
        /etc/init.d/dnsmasq restart
    fi
}

dnsmasqfull() {
    if /usr/sbin/dnsmasq -v | grep -q "no-nftset"; then
        log "Dnsmasq-full is not installed. Future: link only"
        log "Use script or:"
        log "cd /tmp/ && /bin/opkg download dnsmasq-full && /bin/opkg remove dnsmasq && /bin/opkg install dnsmasq-full --cache /tmp/ && cp /etc/config/dhcp /etc/config/dhcp-old && mv /etc/config/dhcp-opkg /etc/config/dhcp"
        return
    fi
}

routing_table_create() {
    grep -q "105 podkop" /etc/iproute2/rt_tables || echo '105 podkop' >>/etc/iproute2/rt_tables
    config_get_bool second_enable "second" "second_enable" "0"
    if [ "$second_enable" -eq 1 ]; then
        grep -q "106 podkop2" /etc/iproute2/rt_tables || echo '106 podkop2' >>/etc/iproute2/rt_tables
    fi
}

add_set() {
    local set_name="$1"
    local connect="$2"

    nft add table inet PodkopTable
    log "Create set $set_name"
    nft add chain inet PodkopTable mangle { type filter hook prerouting priority -150 \; policy accept \;}
    nft add set inet PodkopTable "$set_name" { type ipv4_addr\; flags interval\; auto-merge\; }
    if [ "$connect" = "main" ]; then
        config_get mode "$connect" "mode"
    else
        config_get mode "$connect" "second_mode"
    fi
    case "$mode" in
    "vpn")
        if ! nft list chain inet PodkopTable mangle | grep -q "ip daddr @"$set_name" meta mark set"; then
            if [ "$connect" = "main" ]; then
                nft add rule inet PodkopTable mangle iifname "br-lan" ip daddr @"$set_name" meta mark set 0x105 counter
            elif [ "$connect" = "second" ]; then
                nft add rule inet PodkopTable mangle iifname "br-lan" ip daddr @"$set_name" meta mark set 0x106 counter
            fi
        fi
        ;;

    "proxy")
        nft add chain inet PodkopTable proxy { type filter hook prerouting priority -100 \; }
        if nft list table inet PodkopTable | grep -q "ip daddr @"$set_name" meta l4proto"; then
            log "Nft rule tproxy exists"
        else
            log "Added nft rule tproxy"
            if [ "$connect" = "main" ]; then
                nft add rule inet PodkopTable mangle iifname "br-lan" ip daddr @"$set_name" meta l4proto tcp meta mark set 0x105 counter
                nft add rule inet PodkopTable mangle iifname "br-lan" ip daddr @"$set_name" meta l4proto udp meta mark set 0x105 counter
                if ! ( nft list table inet PodkopTable | grep -q "meta mark 0x00000105 meta l4proto tcp tproxy" ); then
                    nft add rule inet PodkopTable proxy meta mark 0x105 meta l4proto tcp tproxy ip to :1602 counter
                    nft add rule inet PodkopTable proxy meta mark 0x105 meta l4proto udp tproxy ip to :1602 counter
                fi
            elif [ "$connect" = "second" ]; then
                nft add rule inet PodkopTable mangle iifname "br-lan" ip daddr @"$set_name" meta l4proto tcp meta mark set 0x106 counter
                nft add rule inet PodkopTable mangle iifname "br-lan" ip daddr @"$set_name" meta l4proto udp meta mark set 0x106 counter
                if ! ( nft list table inet PodkopTable | grep -q "meta mark 0x00000106 meta l4proto tcp tproxy" ); then
                    nft add rule inet PodkopTable proxy meta mark 0x106 meta l4proto tcp tproxy ip to :1603 counter
                    nft add rule inet PodkopTable proxy meta mark 0x106 meta l4proto udp tproxy ip to :1603 counter
                fi
            fi
        fi
        ;;

    *)
        log "Requires *vpn* or *proxy* value"
        return
        ;;
    esac
}

add_route_interface() {
    local interface="$1"
    local table="$2"
    local retry_count_route=0
    local max_retries=10

    if ! ip link show "$interface" >/dev/null 2>&1; then
    log "Interface "$interface" undetected, wait 10 sec..."
    sleep 10

        if ! ip link show "$interface" >/dev/null 2>&1; then
            log "Interface "$interface" undetected. exit"
            return
        fi
    fi

    if ! ip link show "$interface" >/dev/null 2>&1; then
        log "Interface "$interface" does not exist, not possible to create a route"
        return
    fi

    if ip route show table $table | grep -q "^default dev"; then
        log "Route for "$interface" exists"
        return 0
    fi

    log "Added route for "$interface""
    while [ $retry_count_route -lt $max_retries ]; do
        if ip route add table $table default dev "$interface" 2>&1 | grep -q "Network is down"; then
            log "Attempt $retry_count_route: Interface "$interface" is down, retrying in 3 seconds..."
            sleep 3
            retry_count_route=$((retry_count_route + 1))
        else
            log "Route for "$interface" added"
            return 0
        fi
    done

    log "The maximum number of attempts has been exceeded. Failed to add a route."
    return
}

add_route_tproxy() {
    local table=$1
    if ! ip route list table $table | grep -q "local default dev lo scope host"; then
        log "Added route for tproxy"
        ip route add local 0.0.0.0/0 dev lo table $table
    else
        log "Route for tproxy exists"
    fi
}

add_mark() {
    if ! ip rule list | grep -q "from all fwmark 0x105 lookup podkop"; then
        log "Create marking rule"
        ip -4 rule add fwmark 0x105 table podkop priority 105
    else
        log "Marking rule exist"
    fi

    config_get_bool second_enable "second" "second_enable" "0"
    if [ "$second_enable" -eq 1 ]; then
        if ! ip rule list | grep -q "from all fwmark 0x106 lookup podkop2"; then
            log "Create marking rule for podkop second"
            ip -4 rule add fwmark 0x106 table podkop2 priority 106
        else
            log "Podkop second marking rule exist"
        fi
    fi
}

lists_domains_download() {
    local URL="$1"

    RU_INSIDE_DOMAINS=https://raw.githubusercontent.com/itdoginfo/allow-domains/main/Russia/inside-dnsmasq-nfset.lst
    RU_OUTSIDE_DOMAINS=https://raw.githubusercontent.com/itdoginfo/allow-domains/main/Russia/outside-dnsmasq-nfset.lst
    UA_DOMAINS=https://raw.githubusercontent.com/itdoginfo/allow-domains/main/Ukraine/inside-dnsmasq-nfset.lst

    case "$URL" in
    "ru_inside")
        URL=$RU_INSIDE_DOMAINS
        ;;
    "ru_outside")
        URL=$RU_OUTSIDE_DOMAINS
        ;;
    "ua")
        URL=$UA_DOMAINS
        ;;
    *)
        log "Unidentified list of domains"
        return
        ;;
    esac

    count=0
    while true; do
        if curl -m 3 github.com; then
            curl -f $URL --output /tmp/dnsmasq.d/podkop-domains.lst
            sed -i 's/fw4#vpn_domains/PodkopTable#podkop_domains/g' /tmp/dnsmasq.d/podkop-domains.lst
            return 0
        else
            log "GitHub is not available. Check the internet availability [$count sec]"
            count=$((count + 1))
        fi

        if [ $count -lt 30 ]; then
            sleep_interval=1
        elif [ $count -ge 30 ] && [ $count -lt 60 ]; then
            sleep_interval=5
        elif [ $count -ge 60 ] && [ $count -lt 90 ]; then
            sleep_interval=10
        else
            sleep_interval=30
        fi

        sleep $sleep_interval
    done
}

lists_services_download() {
    local URL="$1"

    YOUTUBE=https://raw.githubusercontent.com/itdoginfo/allow-domains/refs/heads/main/Services/youtube.lst

    case "$URL" in
    "youtube")
        URL=$YOUTUBE
        ;;
    *)
        log "Unidentified list of domains"
        return
        ;;
    esac

    count=0
    while true; do
        if curl -m 3 github.com; then
            curl -f $URL --output /tmp/dnsmasq.d/podkop2-domains.lst
            delist_downloaded_domains
            sed -i 's/.*/nftset=\/&\/4#inet#PodkopTable#podkop2_domains/g' /tmp/dnsmasq.d/podkop2-domains.lst
            return 0
        else
            log "GitHub is not available. Check the internet availability [$count sec]"
            count=$((count + 1))
        fi

        if [ $count -lt 30 ]; then
            sleep_interval=1
        elif [ $count -ge 30 ] && [ $count -lt 60 ]; then
            sleep_interval=5
        elif [ $count -ge 60 ] && [ $count -lt 90 ]; then
            sleep_interval=10
        else
            sleep_interval=30
        fi

        sleep $sleep_interval
    done
}

list_subnets_download() {
    TWITTER_SUBNETS=https://raw.githubusercontent.com/itdoginfo/allow-domains/main/Subnets/IPv4/Twitter.lst
    META_SUBNETS=https://raw.githubusercontent.com/itdoginfo/allow-domains/main/Subnets/IPv4/Meta.lst
    DISCORD_SUBNETS=https://raw.githubusercontent.com/itdoginfo/allow-domains/refs/heads/main/Subnets/IPv4/Discord.lst
    local URL="$1"

    case "$URL" in
    "twitter")
        URL=$TWITTER_SUBNETS
        ;;
    "meta")
        URL=$META_SUBNETS
        ;;
    "discord")
        URL=$DISCORD_SUBNETS
        ;;
    *)
        log "Custom URL for subnet"
        if curl --output /dev/null --silent --head --fail "$URL"; then
            log "URL is valid"
        else
            log "URL $URL is not valid"
        fi
        ;;
    esac

    local filename=$(basename "$URL")
    curl -f "$URL" --output "/tmp/podkop/$filename"
    while IFS= read -r subnet; do
        nft add element inet PodkopTable podkop_subnets { $subnet }
    done <"/tmp/podkop/$filename"
}

list_custom_domains_create() {
    local domain="$1"
    local name="$2"
    echo "nftset=/$domain/4#inet#PodkopTable#${name}_domains" >>"/tmp/dnsmasq.d/${name}-custom-domains.lst"
    log "$domain added to the list"
}

list_custom_download_domains_create() {
    local URL="$1"
    local name="$2"
    local filename=$(basename "$URL")
    local config="/tmp/dnsmasq.d/${name}-${filename}.lst"

    rm -f $config
    curl -f "$URL" --output "/tmp/podkop/${filename}"
    while IFS= read -r domain; do
        echo "nftset=/$domain/4#inet#PodkopTable#${name}_domains" >>$config
    done <"/tmp/podkop/$filename"
    dnsmasq_config_check ${name}-${filename}.lst
}

list_custom_subnets_create() {
    local subnet="$1"
    local name="$2"
    nft add element inet PodkopTable ${name}_subnets { $subnet }
}

list_all_traffic_from_ip() {
    local ip="$1"
    if ! nft list chain inet PodkopTable mangle | grep -q "ip saddr $ip"; then
        config_get mode "main" "mode" "0"
        if [ "$mode" = "vpn" ]; then
            nft insert rule inet PodkopTable mangle iifname "br-lan" ip saddr $ip meta mark set 0x105 counter
        elif [ "$mode" = "proxy" ]; then
            nft add set inet PodkopTable localv4 { type ipv4_addr\; flags interval\; }
            nft add element inet PodkopTable localv4 { \
                0.0.0.0/8, \
                10.0.0.0/8, \
                127.0.0.0/8, \
                169.254.0.0/16, \
                172.16.0.0/12, \
                192.0.0.0/24, \
                192.0.2.0/24, \
                192.88.99.0/24, \
                192.168.0.0/16, \
                198.18.0.0/15, \
                198.51.100.0/24, \
                203.0.113.0/24, \
                224.0.0.0/4, \
                240.0.0.0-255.255.255.255 }
            nft insert rule inet PodkopTable mangle iifname "br-lan" ip saddr $ip meta l4proto { tcp, udp } meta mark set 0x105 counter
            nft insert rule inet PodkopTable mangle ip saddr $ip ip daddr @localv4 return
        fi
    fi
}

list_exclude_traffic_from_ip() {
    local ip="$1"
    if ! nft list chain inet PodkopTable mangle | grep -q "ip saddr $ip"; then
        nft insert rule inet PodkopTable mangle ip saddr $ip return
    fi
}

list_delist_domains() {
    local domain="$1"

    if [ -f "/tmp/dnsmasq.d/podkop-domains.lst" ]; then
        sed -i "/$domain/d" /tmp/dnsmasq.d/podkop-domains.lst
        nft flush set inet PodkopTable podkop_domains
        log "Strings containing '$domain' have been excluded from the list"
    else
        log "Config /tmp/dnsmasq.d/podkop-domains.lst not exists"
    fi
}

delist_downloaded_domains() {
    local domains="/tmp/dnsmasq.d/podkop2-domains.lst"

    if [ -f "$domains" ]; then
        while IFS= read -r line; do
            list_delist_domains "$line"
        done <"$domains"
    else
        log "$domains not found"
    fi
}

dnsmasq_config_check() {
    local config="$1"
    if ! /usr/sbin/dnsmasq --conf-file=/tmp/dnsmasq.d/$config --test 2>&1 | grep -q "syntax check OK"; then
        log "Dnsmasq config $config contains errors. Break"
        return
    fi
}

sing_box_config_outbound_json() {
    local json_config="$1"
    local listen_port="$2"
    
    # Create temporary file with base config structure
    cat > /tmp/base_config.json << EOF
{
  "log": {
    "level": "warn"
  },
  "inbounds": [
    {
      "type": "tproxy",
      "listen": "::",
      "listen_port": $listen_port,
      "sniff": false
    }
  ],
  "outbounds": [],
  "route": {
    "auto_detect_interface": true
  }
}
EOF

    # Add the outbound config using jq
    jq --argjson outbound "$json_config" '.outbounds += [$outbound]' /tmp/base_config.json > /etc/sing-box/config.json
    
    # Cleanup
    rm -f /tmp/base_config.json
}

sing_box_uci() {
    local config="/etc/config/sing-box"
    if grep -q "option enabled '0'" "$config" ||
        grep -q "option user 'sing-box'" "$config"; then
        sed -i \
            -e "s/option enabled '0'/option enabled '1'/" \
            -e "s/option user 'sing-box'/option user 'root'/" $config
        log "Change sing-box UCI config"
    else
        log "Sing-box UCI config OK"
    fi
}

sing_box_config_shadowsocks() {
    local STRING="$1"
    local listen_port="$2"

    # Определяем тип SS (2022 или old) по наличию : в base64 части
    if echo "$STRING" | cut -d'/' -f3 | cut -d'@' -f1 | base64 -d 2>/dev/null | grep -q ":"; then
        # Old SS format
        local encrypted_part=$(echo "$STRING" | cut -d'/' -f3 | cut -d'@' -f1 | base64 --decode)
        local method=$(echo "$encrypted_part" | cut -d':' -f1)
        local password=$(echo "$encrypted_part" | cut -d':' -f2-)
    else
        # SS 2022 format
        local method_and_password=$(echo "$STRING" | cut -d'/' -f3 | cut -d'@' -f1)
        local method=$(echo "$method_and_password" | cut -d':' -f1)
        local password=$(echo "$method_and_password" | cut -d':' -f2- | sed 's/%3D/=/g')
        
        # Если method в base64, декодируем
        if echo "$method" | base64 -d &>/dev/null; then
            method=$(echo "$method" | base64 -d)
        fi
    fi

    local server=$(echo "$STRING" | cut -d'@' -f2 | cut -d':' -f1)
    local port=$(echo "$STRING" | sed -n 's|.*:\([0-9]\+\).*|\1|p')

    # Create base config
    cat > /tmp/ss_config.json << EOF
{
  "log": {
    "level": "warn"
  },
  "inbounds": [
    {
      "type": "tproxy",
      "listen": "::",
      "listen_port": $listen_port,
      "sniff": false
    }
  ],
  "outbounds": [
    {
      "type": "shadowsocks",
      "server": "$server",
      "server_port": $port,
      "method": "$method",
      "password": "$password",
      "udp_over_tcp": {
        "enabled": true,
        "version": 2
      }
    }
  ],
  "route": {
    "auto_detect_interface": true
  }
}
EOF

    mv /tmp/ss_config.json /etc/sing-box/config.json
}

sing_box_config_vless() {
    local STRING="$1"
    local listen_port="$2"

    get_param() {
        local param="$1"
        local value=$(echo "$STRING" | sed -n "s/.*[?&]$param=\([^&?#]*\).*/\1/p")
        value=$(echo "$value" | sed 's/%2F/\//gi; s/%2C/,/gi; s/%3D/=/gi; s/%2B/+/gi')
        echo "$value"
    }

    uuid=$(echo "$STRING" | cut -d'/' -f3 | cut -d'@' -f1)
    server=$(echo "$STRING" | cut -d'@' -f2 | cut -d':' -f1)
    port=$(echo "$STRING" | cut -d'@' -f2 | cut -d':' -f2 | cut -d'?' -f1 | cut -d'/' -f1)

    type=$(get_param "type")
    security=$(get_param "security")
    sni=$(get_param "sni")
    fp=$(get_param "fp")
    flow=$(get_param "flow")
    
    pbk=$(get_param "pbk")
    sid=$(get_param "sid")

    alpn=$(get_param "alpn")
    if [ -z "$alpn" ]; then
        alpn="h2,http/1.1"
    fi
    alpn_json=$(echo "$alpn" | tr ',' '\n' | jq -R . | jq -s .)

    path=$(get_param "path")
    host=$(get_param "host")

    cat > /tmp/vless_config.json << EOF
{
  "log": {
    "level": "warn"
  },
  "inbounds": [
    {
      "type": "tproxy",
      "listen": "::",
      "listen_port": $listen_port,
      "sniff": false
    }
  ],
  "outbounds": [
    {
      "type": "vless",
      "server": "$server",
      "server_port": $port,
      "uuid": "$uuid"
EOF

    if [ "$type" = "ws" ]; then
        cat >> /tmp/vless_config.json << EOF
,
      "transport": {
        "type": "ws",
        "path": "$path"
EOF
        if [ -n "$host" ]; then
            cat >> /tmp/vless_config.json << EOF
,
        "headers": {
          "Host": "$host"
        }
EOF
        fi
        echo "      }" >> /tmp/vless_config.json
    elif [ "$type" = "grpc" ]; then
        cat >> /tmp/vless_config.json << EOF
,
      "transport": {
        "type": "grpc"
      }
EOF
    fi

    if [ "$security" = "reality" ]; then
        if [ -n "$flow" ]; then
            echo "      ,\"flow\": \"$flow\"" >> /tmp/vless_config.json
        fi
        cat >> /tmp/vless_config.json << EOF
,
      "tls": {
        "enabled": true,
        "server_name": "$sni",
        "utls": {
          "enabled": true,
          "fingerprint": "$fp"
        },
        "reality": {
          "enabled": true,
          "public_key": "$pbk",
          "short_id": "$sid"
        }
      }
EOF
    elif [ "$security" = "tls" ]; then
        if [ -n "$flow" ]; then
            echo "      ,\"flow\": \"$flow\"" >> /tmp/vless_config.json
        fi
        cat >> /tmp/vless_config.json << EOF
,
      "tls": {
        "enabled": true,
        "server_name": "$sni",
        "insecure": $([ "$(get_param 'allowInsecure')" = "1" ] && echo "true" || echo "false"),
        "utls": {
          "enabled": true,
          "fingerprint": "$fp"
        }
EOF
        if [ -n "$alpn" ]; then
            echo "        ,\"alpn\": $alpn_json" >> /tmp/vless_config.json
        fi
        echo "      }" >> /tmp/vless_config.json
    fi

    cat >> /tmp/vless_config.json << EOF
    }
  ],
  "route": {
    "auto_detect_interface": true
  }
}
EOF

    mv /tmp/vless_config.json /etc/sing-box/config.json
}

sing_box_config_outbound_json() {
    local json_config="$1"
    local listen_port="$2"
    
    cat > /tmp/base_config.json << EOF
{
  "log": {
    "level": "warn"
  },
  "inbounds": [
    {
      "type": "tproxy",
      "listen": "::",
      "listen_port": $listen_port,
      "sniff": false
    }
  ],
  "outbounds": [],
  "route": {
    "auto_detect_interface": true
  }
}
EOF

    jq --argjson outbound "$json_config" '.outbounds += [$outbound]' /tmp/base_config.json > /etc/sing-box/config.json
    rm -f /tmp/base_config.json
}

sing_box_config_check() {
    if ! sing-box -c /etc/sing-box/config.json check >/dev/null 2>&1; then
        log "Sing-box configuration is invalid"
        return
    fi
}

process_domains_text() {
    local text="$1"
    local name="$2"
    
    local tmp_file=$(mktemp)
    echo "$text" > "$tmp_file"
    
    sed 's/[, ]\+/\n/g' "$tmp_file" | while IFS= read -r domain; do
        domain=$(echo "$domain" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [ -n "$domain" ]; then
            list_custom_domains_create "$domain" "$name"
        fi
    done
    
    rm -f "$tmp_file"
}

process_subnets_text() {
    local text="$1"
    local name="$2"
    
    local tmp_file=$(mktemp)
    echo "$text" > "$tmp_file"
    
    sed 's/[, ]\+/\n/g' "$tmp_file" | while IFS= read -r subnet; do
        subnet=$(echo "$subnet" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [ -n "$subnet" ]; then
            if ! echo "$subnet" | grep -q "/"; then
                subnet="$subnet/32"
            fi
            list_custom_subnets_create "$subnet" "$name"
        fi
    done
    
    rm -f "$tmp_file"
}

list_custom_subnets_preprocess() {
    local subnet="$1"
    local name="$2"
    
    if ! echo "$subnet" | grep -q "/"; then
        subnet="$subnet/32"
    fi
    list_custom_subnets_create "$subnet" "$name"
}